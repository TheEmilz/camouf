# AI Agent Context Loss and How Camouf Solves It

This guide explains a common class of bugs introduced by AI coding agents and how Camouf's
function signature matching feature helps catch and fix them.

## Table of Contents

- [The Problem: AI Agent Context Windows](#the-problem-ai-agent-context-windows)
- [Real-World Scenarios](#real-world-scenarios)
- [How Camouf Detects Mismatches](#how-camouf-detects-mismatches)
- [Fixing Mismatches](#fixing-mismatches)
- [Configuration](#configuration)
- [Best Practices](#best-practices)

## The Problem: AI Agent Context Windows

AI coding agents (Claude Code, GitHub Copilot, OpenAI Codex, etc.) operate with limited
context windows. When working on a large codebase, they cannot hold the entire project
in memory simultaneously. This leads to a specific class of errors:

**The agent correctly understands the intent but uses slightly different names than
what's defined elsewhere in the codebase.**

This is particularly problematic at frontend/backend boundaries where:

1. The backend defines an API function with specific parameter names
2. The frontend needs to call that function
3. The agent, having lost context of the exact definition, guesses a similar name

The result? Code that **compiles successfully** but **fails at runtime**.

## Real-World Scenarios

### Scenario 1: Function Name Mismatch

```
Backend Contract (shared/api-contracts.ts)
```

```typescript
// The correct definition
export async function getUserById(id: string): Promise<User> {
  // ...
}
```

```
Frontend Code (generated by AI agent)
```

```typescript
// AI agent wrote this without seeing the exact backend definition
const user = await getUser(userId);  // Wrong function name!
```

**What happened**: The agent remembered there was a "get user" function but forgot
the exact name was `getUserById`, not `getUser`.

### Scenario 2: Parameter Name Mismatch

```
Shared DTO (shared/dto/user.dto.ts)
```

```typescript
export interface CreateUserDTO {
  email: string;
  password: string;
  displayName: string;
}
```

```
Frontend Form Handler
```

```typescript
// AI agent wrote this
const payload: CreateUserDTO = {
  userEmail: formData.email,      // Wrong! Should be 'email'
  userPassword: formData.password, // Wrong! Should be 'password'
  name: formData.name,            // Wrong! Should be 'displayName'
};
```

**What happened**: The agent was creating a DTO but used intuitive field names
instead of the exact ones defined in the interface.

### Scenario 3: Type Field Access Mismatch

```
API Response Type
```

```typescript
interface UserResponse {
  data: {
    id: string;
    email: string;
    createdAt: Date;
  };
}
```

```
Component Code
```

```typescript
// AI agent wrote this
const userEmail = response.data.userEmail;  // Wrong! Field is 'email'
const created = response.data.created_at;   // Wrong! Field is 'createdAt'
```

**What happened**: The agent accessed response fields using common naming conventions
instead of the actual field names in the type definition.

## How Camouf Detects Mismatches

Camouf's `function-signature-matching` rule works in three phases:

### Phase 1: Export Extraction

Camouf scans directories you configure as "shared" (e.g., `shared/`, `contracts/`,
`types/`) and extracts:

- Function names and their parameters
- Interface and type definitions with their fields
- Class methods from exported classes

### Phase 2: Usage Analysis

Camouf then scans your client and server directories, looking for:

- Function calls that don't match any known export
- Object field accesses that don't match type definitions
- Named arguments that don't match parameter names

### Phase 3: Fuzzy Matching

Instead of just flagging unknown names, Camouf uses **Levenshtein distance** to find
names that are *similar* to defined names. This catches the common AI agent mistake
of using a *close but not exact* name.

```
Architecture Analysis
```

```
Shared Contracts                              Frontend/Backend Code
┌─────────────────────────┐                  ┌─────────────────────────┐
│ getUserById(id)         │◄─── Compare ───►│ getUser(userId)         │
│ CreateUserDTO.email     │◄─── Compare ───►│ payload.userEmail       │
│ Response.createdAt      │◄─── Compare ───►│ data.created_at         │
└─────────────────────────┘                  └─────────────────────────┘
         │                                            │
         │                                            │
         ▼                                            ▼
    Exact Names                              Similar Names (Warning!)
         │                                            │
         └──────────────── Mismatch Report ───────────┘
```

## Fixing Mismatches

### Method 1: Interactive CLI

```bash
npx camouf fix-signatures --interactive
```

This walks you through each mismatch and asks for confirmation:

```
[sig-001] function-name
  File: src/frontend/api.ts:42
  Change: "getUser" -> "getUserById"
  Apply this fix? (y/n/q):
```

### Method 2: Automatic Fix All

```bash
npx camouf fix-signatures --all
```

Applies all recommended fixes automatically. Use `--dry-run` first to preview:

```bash
npx camouf fix-signatures --all --dry-run
```

### Method 3: Fix by ID

Each mismatch has a unique ID (e.g., `sig-001`). Fix a specific one:

```bash
npx camouf fix --id sig-001
```

### Method 4: Let Your AI Agent Fix It

Use the `/camouf-fix-signatures` slash command in Claude Code:

```
/camouf-fix-signatures
```

The agent will:
1. Run validation
2. Parse the mismatch report
3. Read each affected file
4. Apply the rename
5. Re-validate

## Configuration

### Basic Configuration

In your `camouf.config.json`:

```json
{
  "rules": {
    "builtin": {
      "function-signature-matching": "error"
    }
  },
  "directories": {
    "shared": ["shared", "contracts", "types"],
    "client": ["frontend", "client", "web"],
    "server": ["backend", "server", "api"]
  }
}
```

### Advanced Options

```json
{
  "rules": {
    "builtin": {
      "function-signature-matching": {
        "level": "error",
        "options": {
          "similarityThreshold": 0.7,
          "checkParameterNames": true,
          "checkTypeFields": true,
          "sharedDirectories": ["shared", "packages/types"],
          "clientDirectories": ["apps/web", "apps/mobile"],
          "serverDirectories": ["apps/api"]
        }
      }
    }
  }
}
```

**Options explained:**

| Option | Default | Description |
|--------|---------|-------------|
| `similarityThreshold` | `0.7` | Minimum similarity (0-1) to flag as potential mismatch. Lower = more sensitive |
| `checkParameterNames` | `true` | Check function parameter names in object-style calls |
| `checkTypeFields` | `true` | Check type/interface field access |
| `sharedDirectories` | `["shared"]` | Directories containing contract definitions |
| `clientDirectories` | `["client"]` | Frontend code directories |
| `serverDirectories` | `["server"]` | Backend code directories |

## Best Practices

### 1. Run Validation Before Commits

Add to your pre-commit hook or CI pipeline:

```bash
npx camouf validate --format json --ci --rules function-signature-matching
```

### 2. Generate HTML Reports

For team review, generate an interactive HTML report:

```bash
npx camouf report --format html --output camouf-report/
```

Open `camouf-report/signature-mismatches.html` for a visual overview with quick-fix commands.

### 3. Configure AI Agent Instructions

If using Claude Code or Codex, run:

```bash
npx camouf init --agent all
```

This generates:
- `CLAUDE.md` / `AGENTS.md` with Camouf instructions
- `.claude/commands/camouf-fix-signatures.md` slash command
- `.claude/rules/camouf.md` for persistent rule awareness

### 4. Centralize Type Definitions

Organize your project to have a clear "shared contracts" location:

```
project/
├── shared/
│   ├── api-contracts.ts      # Function signatures
│   ├── dto/                   # Data Transfer Objects
│   │   ├── user.dto.ts
│   │   └── order.dto.ts
│   └── types/                # Shared types
│       └── responses.ts
├── frontend/
│   └── ...                   # Uses shared contracts
└── backend/
    └── ...                   # Implements shared contracts
```

### 5. Use TypeScript Strictly

Enable strict TypeScript options to catch more issues at compile time:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

## Understanding the Report

When Camouf finds mismatches, the JSON output looks like:

```json
{
  "summary": {
    "total": 3,
    "errors": 3,
    "warnings": 0
  },
  "violations": [
    {
      "id": "function-signature-matching-...",
      "ruleId": "function-signature-matching",
      "severity": "error",
      "message": "Function name mismatch: 'getUser' called but 'getUserById' is defined",
      "file": "src/frontend/api.ts",
      "line": 42,
      "suggestion": "Rename to 'getUserById'. This may be a context loss issue from AI-generated code.",
      "metadata": {
        "mismatchType": "function-name",
        "expected": "getUserById",
        "found": "getUser",
        "similarity": 0.75,
        "definedIn": {
          "file": "src/shared/api-contracts.ts",
          "line": 15
        },
        "quickFixId": "sig-001",
        "quickFixCommand": "npx camouf fix --id sig-001"
      }
    }
  ]
}
```

**Key fields:**
- `metadata.expected`: The correct name as defined in shared contracts
- `metadata.found`: The incorrect name being used
- `metadata.similarity`: How similar the names are (1.0 = exact match)
- `metadata.definedIn`: Where the correct definition lives
- `metadata.quickFixCommand`: Ready-to-run fix command

## Summary

AI coding agents are incredibly powerful but can introduce subtle bugs due to context
limitations. The `function-signature-matching` rule in Camouf acts as a safety net,
catching these mismatches before they reach production.

Key takeaways:

1. **AI agents guess similar names** when they lose context of exact definitions
2. **These bugs compile** but fail at runtime
3. **Camouf detects them** using fuzzy matching against your shared contracts
4. **Quick-fix commands** let you or your AI agent resolve them instantly

Run `npx camouf validate` regularly and integrate it into your CI/CD pipeline for
continuous architecture monitoring.
